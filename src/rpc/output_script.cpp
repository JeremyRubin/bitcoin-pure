// Copyright (c) 2010 Satoshi Nakamoto
// Copyright (c) 2009-2022 The Bitcoin Core developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#include <key_io.h>
#include <outputtype.h>
#include <pubkey.h>
#include <rpc/protocol.h>
#include <rpc/request.h>
#include <rpc/server.h>
#include <rpc/util.h>
#include <script/script.h>
#include <tinyformat.h>
#include <univalue.h>
#include <util/check.h>
#include <util/strencodings.h>

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <tuple>
#include <vector>

static RPCHelpMan validateaddress()
{
    return RPCHelpMan{
        "validateaddress",
        "\nReturn information about the given bitcoin address.\n",
        {
            {"address", RPCArg::Type::STR, RPCArg::Optional::NO, "The bitcoin address to validate"},
        },
        RPCResult{
            RPCResult::Type::OBJ, "", "",
            {
                {RPCResult::Type::BOOL, "isvalid", "If the address is valid or not"},
                {RPCResult::Type::STR, "address", /*optional=*/true, "The bitcoin address validated"},
                {RPCResult::Type::STR_HEX, "scriptPubKey", /*optional=*/true, "The hex-encoded scriptPubKey generated by the address"},
                {RPCResult::Type::BOOL, "isscript", /*optional=*/true, "If the key is a script"},
                {RPCResult::Type::BOOL, "iswitness", /*optional=*/true, "If the address is a witness address"},
                {RPCResult::Type::NUM, "witness_version", /*optional=*/true, "The version number of the witness program"},
                {RPCResult::Type::STR_HEX, "witness_program", /*optional=*/true, "The hex value of the witness program"},
                {RPCResult::Type::STR, "error", /*optional=*/true, "Error message, if any"},
                {RPCResult::Type::ARR, "error_locations", /*optional=*/true, "Indices of likely error locations in address, if known (e.g. Bech32 errors)",
                    {
                        {RPCResult::Type::NUM, "index", "index of a potential error"},
                    }},
            }
        },
        RPCExamples{
            HelpExampleCli("validateaddress", "\"" + EXAMPLE_ADDRESS[0] + "\"") +
            HelpExampleRpc("validateaddress", "\"" + EXAMPLE_ADDRESS[0] + "\"")
        },
        [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue
        {
            std::string error_msg;
            std::vector<int> error_locations;
            CTxDestination dest = DecodeDestination(request.params[0].get_str(), error_msg, &error_locations);
            const bool isValid = IsValidDestination(dest);
            CHECK_NONFATAL(isValid == error_msg.empty());

            UniValue ret(UniValue::VOBJ);
            ret.pushKV("isvalid", isValid);
            if (isValid) {
                std::string currentAddress = EncodeDestination(dest);
                ret.pushKV("address", currentAddress);

                CScript scriptPubKey = GetScriptForDestination(dest);
                ret.pushKV("scriptPubKey", HexStr(scriptPubKey));

                UniValue detail = DescribeAddress(dest);
                ret.pushKVs(detail);
            } else {
                UniValue error_indices(UniValue::VARR);
                for (int i : error_locations) error_indices.push_back(i);
                ret.pushKV("error_locations", error_indices);
                ret.pushKV("error", error_msg);
            }

            return ret;
        },
    };
}




void RegisterOutputScriptRPCCommands(CRPCTable& t)
{
    static const CRPCCommand commands[]{
        {"util", &validateaddress},
    };
    for (const auto& c : commands) {
        t.appendCommand(c.name, &c);
    }
}
